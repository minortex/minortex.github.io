+++
date = '2025-07-02T11:28:27+08:00'
draft = false
title = '操作系统 设备和驱动程序(1)'
+++

## 插上u盘，是如何工作的？

usb控制器检测到电平变化 -> 硬件中断 -> 总线驱动捕获中断 -> sysfs创建设备目录和属性文件 -> 内核通过`netlink`发出uevent消息，广播

## 为什么udev的效率高？

1. udev被内核发送的uevent唤醒，而不是一直去轮询内核。

2. udev是并行工作的。在多个设备插入的时候，为每个事件启动一个处理实例。

3. udev使用的Netlink为传递短小的控制信息优化，比其他IPC更加轻量和迅速。

4. udev启动的时候会读取所有`.rules`文件，并解析成快速查询的内存数据结构。（这个就像mihomo一样，提前把规则处理成一个搜索树，使得匹配效率大幅提高）

## I/O设备控制

X86同时支持MMIO/PMIO，ARM只支持MMIO。

通过一条线，一条指令就可以实现控制。

控制方式：

- **MMIO**: 把外部控制寄存器映射到内存地址空间。使得一块特定的内存地址不再对应物理RAM。像这块内存地址写入，就是发送到硬件的控制寄存器，而从这里读取，就是获取寄存器当前的状态。

- **PMIO**: （微机里面的IN/OUT指令）

> 使用内存的地址空间，不会造成存的浪费吗？

早期的32位系统，你安装了4G内存，会发现只有3.几可用，剩下为硬件保留的内存就是这个原因。一般都是被强制保留给PCIe的MMIO。

## GPIO

一个通用的IO，有别于专用IO（USB/HDMI）。可以编程，可以作为输入或者输出。

- 输入模式：读取外部世界。通过这个引脚送过来的电平是高或者低来感知外部世界。

- 输出模式：设置这个引脚为高电平或者低电平，从而控制外部设备。